enum Result<T, E>:
    Ok: (T)
    Err: (E)

fn simulate_operation(name: str, should_fail: bool) -> Result<str, string>:
    println(f"Starting operation: {name}")
    if should_fail:
        return Result.Err("Operation failed")
    let result = f"Result of {name}"
    println(f"Successfully completed: {result}")
    return Result.Ok(result)

fn demonstrate_cleanup():
    println("Demonstrating Cleanup Patterns")
    println("=============================")
    # Simulate finally with explicit cleanup after match
    match simulate_operation("task1", false):
        case Result.Ok(result):
            println(f"Got result: {result}")
        case Result.Err(error):
            println("Operation failed: error occurred")
    println("Cleaning up after task1")
    
    match simulate_operation("task2", true):
        case Result.Ok(result):
            println(f"Got result: {result}")
        case Result.Err(error):
            println("Operation failed: error occurred")
    println("Cleaning up after task2")

fn resource_management_demo():
    println("Resource Management with Cleanup")
    println("=================================")
    println("Acquiring resource: Database")
    println("Acquiring resource: Network")
    println("Acquiring resource: File")
    
    match simulate_operation("processing", true):
        case Result.Ok(_):
            println("All operations completed successfully")
        case Result.Err(error):
            println("Operation failed: error occurred")
    
    # Cleanup always happens
    println("Releasing resource: Database")
    println("Releasing resource: Network")
    println("Releasing resource: File")

fn main():
    println("Error Handling - Resource Management")
    println("====================================")
    demonstrate_cleanup()
    println("")
    resource_management_demo()
